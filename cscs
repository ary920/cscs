import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = "aaaa.jpg"  # Replace with the correct image file path
img = cv2.imread(image_path)

# Check if the image was loaded successfully
if img is None:
    print("Error: Image not found! Please check the file path.")
    exit()

# Convert the image to RGB and grayscale
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Function for applying Gaussian blur
def apply_gaussian_blur(image, kernel_size=(5, 5), sigma=0):
    return cv2.GaussianBlur(image, kernel_size, sigma)

# Apply Gaussian blur
img_blur = apply_gaussian_blur(img_gray)

# Function for performing Canny edge detection
def canny_edge_detection(image, threshold1, threshold2):
    return cv2.Canny(image, threshold1, threshold2)

# Perform edge detection
edges = canny_edge_detection(img_blur, 100, 200)

# Resize the edge-detected image
def resize_image(image, dimensions=(300, 300)):
    return cv2.resize(image, dimensions)

resized_edges = resize_image(edges)

# Apply rotation
def rotate_image(image, angle, scale=1.0):
    height, width = image.shape[:2]
    center = (width // 2, height // 2)
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, scale)
    return cv2.warpAffine(image, rotation_matrix, (width, height))

rotated_edges = rotate_image(resized_edges, 45)

# Apply contrast stretching
def contrast_stretching(image, in_range=(50, 200), out_range=(0, 255)):
    in_min, in_max = in_range
    out_min, out_max = out_range
    stretched = ((image - in_min) * ((out_max - out_min) / (in_max - in_min)) + out_min)
    return np.clip(stretched, out_min, out_max).astype(np.uint8)

contrast_image = contrast_stretching(img_gray)

# Apply histogram equalization
hist_eq_image = cv2.equalizeHist(img_gray)

# Apply logarithmic transformation
def logarithmic_transformation(image):
    c = 255 / (np.log(1 + np.max(image) + 1e-5))
    return (c * np.log(1 + image)).astype(np.uint8)

log_image = logarithmic_transformation(img_gray)

# Apply gamma correction
def gamma_correction(image, gamma):
    normalized_image = image / 255.0
    gamma_corrected = (255 * (normalized_image ** gamma)).astype(np.uint8)
    return gamma_corrected

gamma_corrected = gamma_correction(img_gray, gamma=0.5)

# Display results
plt.figure(figsize=(15, 15))

plt.subplot(3, 3, 1)
plt.imshow(img_rgb)
plt.title("Original Image (RGB)")
plt.axis('off')

plt.subplot(3, 3, 2)
plt.imshow(img_gray, cmap='gray')
plt.title("Grayscale Image")
plt.axis('off')

plt.subplot(3, 3, 3)
plt.imshow(edges, cmap='gray')
plt.title("Edge Detection (Canny)")
plt.axis('off')

plt.subplot(3, 3, 4)
plt.imshow(resized_edges, cmap='gray')
plt.title("Resized Edge Image")
plt.axis('off')

plt.subplot(3, 3, 5)
plt.imshow(rotated_edges, cmap='gray')
plt.title("Rotated Edge Image")
plt.axis('off')

plt.subplot(3, 3, 6)
plt.imshow(contrast_image, cmap='gray')
plt.title("Contrast Stretching")
plt.axis('off')

plt.subplot(3, 3, 7)
plt.imshow(log_image, cmap='gray')
plt.title("Logarithmic Transformation")
plt.axis('off')

plt.subplot(3, 3, 8)
plt.imshow(hist_eq_image, cmap='gray')
plt.title("Histogram Equalization")
plt.axis('off')

plt.tight_layout()
plt.show()

# Plot histograms for grayscale and histogram-equalized images
plt.figure(figsize=(12, 10))

# Original histogram
plt.subplot(1, 2, 1)
plt.hist(img_gray.ravel(), bins=256, range=[0, 256], color='blue', alpha=0.7)
plt.title("Original Grayscale Histogram")
plt.xlabel("Pixel Intensity")
plt.ylabel("Frequency")
plt.grid()

# Equalized histogram
plt.subplot(1, 2, 2)
plt.hist(hist_eq_image.ravel(), bins=256, range=[0, 256], color='green', alpha=0.7)
plt.title("Histogram Equalized")
plt.xlabel("Pixel Intensity")
plt.ylabel("Frequency")
plt.grid()

plt.tight_layout()
plt.show()

































